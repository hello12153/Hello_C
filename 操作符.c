#define _CRT_SECURE_NO_WARNINGS 1
/*
* @Author: hello_chen
* @Description:
* @Versions：1.0
*/

/*
* 操作符：算术操作符，移位操作符，位操作符，赋值操作符，单目操作符，关系操作符，逻辑操作符，条件操作符，逗号表达式，下标引用、函数调用和结构成员
* 
* 移位(2进制)操作符：
*	<<     左移运算符，用于将整数左移指定位数，移位规则：左边抛弃、右边补0
*	>>     右移运算符，用于将整数右移指定位数，移位规则：首先右移运算分两种：
*				逻辑移位（无符号） 左边用0填充，右边丢弃
*				算术移位（有符号） 左边用原该值的符号位填充，右边丢弃
* 
*	例：int a = 1;  
*		a<<1;  
*		整型1占4个字节，一个字节8个bit， 32bit位，1个bit用0或1表示，00000000 代表一个字节
*		00000000 00000000 00000000 00000001
*		<<1 向左移1个bit，左边溢出的0去掉，右边补一个0
*		00000000 00000000 00000000 00000010
*
* 位(2进制)操作符：
*	&      按位与，有0为0，在C语言中0为假，1为真，与就是有一个是假即为假
*	|      按位或，有1为1，或就是有一个是真即为真
*	^      按位异或，相同为0，不同为1
* 
*	例：int a = 3; 
*		int b = 5;
*		a & b == 3 & 5
*		10进制   二进制
*		3   ==   0011
*		5   ==   0101
*		3&5 ==   0001   ==  1（10进制）
*		
* 复合赋值符：
*	=  +=  -=  *=  /=  
*	&=  ^=  |=  
*	>>=  <<=  
* 
*	例：
*		int a = 1;
*		a += 1;   等价于  a = a + 1;
*
* 单目、双目、三目操作符
*	! 逻辑反操作，把操作数的真假互换
*	~ 对一个数的二进制按位取反,把其二进制的1变成0,0变成1
*	sizeof  取操作数的类型长度
*	--、++  使操作数减或加1，在操作数前置和在操作数后置结果不同
*	(类型)  强制类型转换，可能会丢失精准度
*	例：
*		int a, b;
*		a = 5;
*		b = a++;    后置++在操作数参与运算后自增1，此处的b=5，a=6
*		b = ++a;    前置++在操作数参与运算前自增1，此处的b=6，a=6
* 
* 逻辑操作符
*	&&  逻辑与，只有两边同时为真则为真，否则为假
*	||  逻辑或，两边只要有一个为真则为真，否则为假
*	例：
*		int a = 5;
*		int b = 6;
*		int c = a && b;
*		a && b ==>  非0 && 非0 == 1
* 
*条件操作符
*	exp1 ? exp2 : exp3
*	exp为表达式，如果表达式exp1的结果为真，则运行exp2的结果，否则，运行exp3的结果
*	例：
*		if(a>b)
*			printf("%d",a);
*		else
*			printf("%d",b);
*		以下的代码等价以上面的代码
*		int max = a>b ? a : b;
*		printf("%d",max);
* 
* 下标引用、函数调用和结构成员
*	[] () . ->
*	例1：
*		int arr[5] ={1,2,3,4,5};
*		arr[4]; //此处的 [] 为下标引用操作符
*	例2：
*		int Add(int a, int b)//此处的Add为函数
*		int num = Add(a,b);//此处的 () 为函数调用操作符
*	
* 
*/

#include<stdio.h>

int Operators();

int Operators()
{
	int a = 3;
	int b = 5;
	int arr[] = { 1,2,3,4,5,6 };
	
	//移位(2进制)操作符
	//a移位后的值，a不变
	printf("%d\n", a << 2);
	
	// 位(2进制)操作符
	//3   --> 011
	//5   --> 101
	//3&5 --> 001 --> 1
	printf("%d\n", a & b);//1

	//~
	//负数在却嬷写娲⒌氖嵌进制的补码
	//而在打印输出时是这个数的原码
	//原码符号位不变其他位取反，得到反码，反码加一得到补码
	//补码减一，得到反码，符号位不变其他位取反得到原码
	//00000000 00000000 00000000 00000101   5
	//11111111 11111111 11111111 11111010   ~5
	//11111111 11111111 11111111 11111001	对~5进行补码
	//10000000 00000000 00000000 00000110	再对其反码得到源码-6
	printf("%d\n", ~b);//-6

	//sizeof
	printf("%d\n", sizeof(a));
	printf("%d\n", sizeof(int));
	printf("%d\n", sizeof a);
	//下面的表达式不可行
	//printf("%d\n", sizeof int);
	//sizeof计算数组时是计算其大小而不是类型长度，单位也是字节，是所有元素的字节总和
	printf("%d\n", sizeof(arr));//6个元素 * 4bit
	// sizeof(arr)/sizeof(arr[0]) = 数组长度也是元素个数

	//++、--
	a = ++b;
	printf("a = %d\n", a);
	printf("b = %d\n", b);

	return 0;
}